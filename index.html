<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
<title>Forklift Surfer 3D (Starter)</title>
<style>
  :root { color-scheme: dark; --bg:#0b0f15; --panel:#121826; --muted:#8aa0c0; --accent:#00d084; }
  html,body{margin:0;height:100%;background:var(--bg);overflow:hidden;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
  #hud{position:fixed;left:0;right:0;top:10px;display:flex;justify-content:center;z-index:5;pointer-events:none}
  #hud .card{display:flex;gap:14px;align-items:center;background:#0f1729cc;border:1px solid #1e293b;border-radius:12px;padding:6px 12px;color:#e6edf7;backdrop-filter:blur(6px);font-weight:600}
  .kv{display:flex;gap:6px}.k{font-size:.72rem;color:var(--muted);text-transform:uppercase;letter-spacing:.08em}.v{font-variant-numeric:tabular-nums}
  #overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:6}
  #overlay .panel{background:#0f1729;border:1px solid #22304d;border-radius:14px;padding:18px 20px;min-width:min(520px,92vw);color:#e6edf7;box-shadow:0 20px 60px rgba(0,0,0,.4)}
  .panel h1{margin:0 0 10px 0;font-size:22px}
  .panel p{margin:8px 0 14px 0;color:#a9bad5}
  .btn{appearance:none;border:1px solid #22304d;background:#121c30;color:#e6edf7;padding:10px 14px;border-radius:10px;font-weight:700;cursor:pointer}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:flex-end}
  #overlay.hidden{display:none}
  #toast{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#0f1729e6;border:1px solid #22304d;color:#e6edf7;border-radius:10px;padding:8px 12px;z-index:7;display:none}
  #toast.show{display:block}
</style>
</head>
<body>
<div id="hud">
  <div class="card">
    <div class="kv"><span class="k">Score</span><span class="v" id="scoreV">0</span></div>
    <div class="kv"><span class="k">Coins</span><span class="v" id="coinV">0</span></div>
    <div class="kv"><span class="k">Best</span><span class="v" id="bestV">0</span></div>
    <div class="kv"><span class="k">Speed</span><span class="v" id="spdV">0</span></div>
    <div class="kv"><span class="k">Magnet</span><span class="v" id="magV">—</span></div>
  </div>
</div>

<div id="overlay">
  <div class="panel">
    <h1>Forklift Surfer 3D</h1>
    <p>Swipe / Keys: <b>← →</b> change lane, <b>↑</b> jump, <b>↓</b> slide. Avoid obstacles, grab coins.</p>
    <div class="row">
      <button class="btn" id="playBtn">Play</button>
    </div>
  </div>
</div>

<div id="toast">Magnet!</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

const hud = {
  score: document.getElementById('scoreV'),
  coins: document.getElementById('coinV'),
  best:  document.getElementById('bestV'),
  speed: document.getElementById('spdV'),
  mag:   document.getElementById('magV'),
};
const overlay = document.getElementById('overlay');
const playBtn = document.getElementById('playBtn');
const toast = document.getElementById('toast');

// ---------- Renderer / Scene / Camera ----------
const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x0b0f15, 1);
document.body.prepend(renderer.domElement);

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0b0f15, 0.06);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 200);
camera.position.set(0, 4.2, 8);
camera.lookAt(0, 1.5, -4);

// Lights
const amb = new THREE.AmbientLight(0xffffff, 0.6);
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(3, 6, 4);
scene.add(amb, dir);

// ---------- Lane / Track ----------
const LANES = [-2.2, 0, 2.2]; // x positions for 3 lanes
const TRACK_LEN = 40;         // length of each floor tile
const TRACK_COUNT = 10;       // how many tiles we recycle
const trackGroup = new THREE.Group();
scene.add(trackGroup);

const floorMat = new THREE.MeshStandardMaterial({ color: 0x121c2e, roughness: 0.9, metalness: 0.0 });
for (let i=0;i<TRACK_COUNT;i++){
  const geo = new THREE.BoxGeometry(7.8, 0.1, TRACK_LEN);
  const mesh = new THREE.Mesh(geo, floorMat);
  mesh.position.set(0, 0, -i*TRACK_LEN);
  mesh.receiveShadow = true;
  trackGroup.add(mesh);
}
// Lane stripes
const stripeMat = new THREE.MeshStandardMaterial({ color: 0x2b3d5e, roughness: 1 });
const stripeGeo = new THREE.BoxGeometry(0.06, 0.02, TRACK_LEN);
const s1 = new THREE.Mesh(stripeGeo, stripeMat);
const s2 = new THREE.Mesh(stripeGeo, stripeMat);
s1.position.set(LANES[0]+(LANES[1]-LANES[0])/2, 0.06, -TRACK_LEN/2);
s2.position.set(LANES[1]+(LANES[2]-LANES[1])/2, 0.06, -TRACK_LEN/2);
trackGroup.add(s1, s2);

// ---------- Forklift (simple low‑poly) ----------
function makeForklift() {
  const g = new THREE.Group();
  // body
  const body = new THREE.Mesh(new THREE.BoxGeometry(1.1, 1.4, 2), new THREE.MeshStandardMaterial({ color: 0x00d084, metalness:0.1, roughness:0.6 }));
  body.position.y = 0.8;
  g.add(body);
  // cab
  const cab = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.8, 1.0), new THREE.MeshStandardMaterial({ color: 0x1b2a41, roughness:0.8 }));
  cab.position.set(0, 1.2, -0.1);
  g.add(cab);
  // forks
  const forkMat = new THREE.MeshStandardMaterial({ color: 0xa1b5d8, metalness:0.5, roughness:0.3 });
  const fork1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.08, 1.0), forkMat);
  const fork2 = fork1.clone();
  fork1.position.set(-0.2, 0.3, 1.2);
  fork2.position.set(0.2, 0.3, 1.2);
  g.add(fork1, fork2);
  // wheels
  const wheelGeo = new THREE.CylinderGeometry(0.22, 0.22, 0.5, 16);
  const wheelMat = new THREE.MeshStandardMaterial({ color: 0x0b1020, roughness:1 });
  const w1 = new THREE.Mesh(wheelGeo, wheelMat);
  const w2 = w1.clone(); const w3 = w1.clone(); const w4 = w1.clone();
  [w1,w2,w3,w4].forEach(w=>w.rotation.z = Math.PI/2);
  w1.position.set(-0.5, 0.25, -0.6);
  w2.position.set( 0.5, 0.25, -0.6);
  w3.position.set(-0.5, 0.25,  0.8);
  w4.position.set( 0.5, 0.25,  0.8);
  g.add(w1,w2,w3,w4);
  // shadow disc
  const sh = new THREE.Mesh(new THREE.CircleGeometry(0.9, 24), new THREE.MeshBasicMaterial({ color:0x000000, transparent:true, opacity:0.25 }));
  sh.rotation.x = -Math.PI/2;
  sh.position.y = 0.01;
  g.add(sh);
  return g;
}
const forklift = makeForklift();
scene.add(forklift);
forklift.position.set(LANES[1], 0, 2);

// ---------- Obstacles / Coins / Powerups ----------
const pool = { obst: [], coin: [], power: [] };
const active = { obst: [], coin: [], power: [] };

function makeBarrier() {
  const m = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.9, 1.0),
    new THREE.MeshStandardMaterial({ color: 0xff7a00, roughness:0.8 }));
  const stripe = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.2, 0.2),
    new THREE.MeshStandardMaterial({ color: 0xffe1bf, roughness:1 }));
  stripe.position.z = 0.0;
  m.add(stripe);
  return m;
}
function makeGate() {
  const m = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.3, 1.0),
    new THREE.MeshStandardMaterial({ color: 0x9aa6bd, roughness:0.8 }));
  m.position.y = 1.2; // overhead
  return m;
}
function makeCoin() {
  const geo = new THREE.CylinderGeometry(0.25,0.25,0.08, 24);
  const mat = new THREE.MeshStandardMaterial({ color: 0xf6c34a, metalness:0.2, roughness:0.4, emissive:0x201500, emissiveIntensity:0.25 });
  const m = new THREE.Mesh(geo, mat);
  m.rotation.x = Math.PI/2;
  return m;
}
function makePowerMagnet() {
  const m = new THREE.Mesh(new THREE.TorusGeometry(0.35,0.12,12,24),
    new THREE.MeshStandardMaterial({ color: 0x60a5fa, roughness:0.3, metalness:0.4, emissive:0x0a3058, emissiveIntensity:0.3 }));
  return m;
}

function spawnObstacle(zFar) {
  const kind = Math.random()<0.55 ? 'barrier' : 'gate';
  const mesh = kind==='barrier' ? (pool.obst.pop() || makeBarrier()) : (pool.obst.pop() || makeGate());
  mesh.userData.kind = kind;
  mesh.position.set(LANES[Math.floor(Math.random()*3)], 0, zFar);
  scene.add(mesh); active.obst.push(mesh);
}
function spawnCoinLine(zFar){
  const lane = Math.floor(Math.random()*3);
  for (let i=0;i<6;i++){
    const c = pool.coin.pop() || makeCoin();
    c.userData.taken = false;
    c.position.set(LANES[lane], 0.6, zFar - i*3);
    scene.add(c); active.coin.push(c);
  }
}
function spawnPower(zFar){
  const p = pool.power.pop() || makePowerMagnet();
  p.userData.kind='magnet'; p.userData.taken=false;
  p.position.set(LANES[Math.floor(Math.random()*3)], 0.8, zFar);
  scene.add(p); active.power.push(p);
}

// ---------- Game State ----------
const keys = new Set();
addEventListener('keydown', e=>{
  keys.add(e.code);
  if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Space'].includes(e.code)) e.preventDefault();
});
addEventListener('keyup', e=> keys.delete(e.code));

// swipe
let touch=null;
addEventListener('pointerdown', e=>{ touch={x:e.clientX,y:e.clientY}; });
addEventListener('pointerup', e=>{
  if (!touch) return;
  const dx = e.clientX - touch.x, dy = e.clientY - touch.y;
  const ax = Math.abs(dx), ay = Math.abs(dy);
  if (ax>30 || ay>30){
    if (ax>ay) { if (dx>0) laneRight(); else laneLeft(); }
    else { if (dy<0) jump(); else slide(); }
  }
  touch=null;
});

const game = {
  running: false, over: false,
  speed: 16, base: 16, max: 46, accel: 0.010,
  lane: 1, laneTarget: 1, laneLerp: 0, laneTime: 0.14,
  jumpT: 0, jumpDur: 0.9, jumpH: 1.25,
  slideT: 0, slideDur: 0.6,
  dist: 0, score: 0, coins: 0, best: 0,
  magnet: 0, invul: 0,
  spawnTimers: { obst: 0, coin: 0, power: 0 },
};
try { game.best = +(localStorage.getItem('fork3d_best')||0); } catch {}
hud.best.textContent = game.best;

function laneLeft(){ game.laneTarget = Math.max(0, game.laneTarget-1); game.laneLerp = 0; }
function laneRight(){ game.laneTarget = Math.min(2, game.laneTarget+1); game.laneLerp = 0; }
function jump(){ if (game.jumpT<=0) game.jumpT = game.jumpDur; }
function slide(){ if (game.slideT<=0) game.slideT = game.slideDur; }

function playerBox() {
  // world coords near forklift
  const x = forklift.position.x;
  const yBase = 0.3; // feet
  const isSlide = game.slideT>0;
  const w = 0.9, h = isSlide ? 0.9 : 1.4, d = 1.4;
  return { x, y: yBase + jumpOffset(), z: forklift.position.z, w, h, d };
}
function jumpOffset(){
  if (game.jumpT<=0) return 0;
  const t = 1 - (game.jumpT / game.jumpDur);
  return (1 - (2*t-1)*(2*t-1)) * game.jumpH;
}
function laneX(){
  if (game.laneTarget === game.lane) return LANES[game.lane];
  const from = LANES[game.lane], to = LANES[game.laneTarget];
  const t = Math.min(1, game.laneLerp / game.laneTime);
  if (t>=1) game.lane = game.laneTarget;
  return from + (to-from) * easeOutCubic(t);
}
function easeOutCubic(t){ return 1 - Math.pow(1-t, 3); }

// ---------- Loop ----------
let last=0;
function startGame(){
  overlay.classList.add('hidden');
  game.running=true; game.over=false;
  game.speed=game.base; game.lane=1; game.laneTarget=1; game.laneLerp=0;
  game.jumpT=0; game.slideT=0; game.dist=0; game.score=0; game.coins=0; game.magnet=0; game.invul=0;
  clearActive();
  last=0;
  animate(performance.now());
}
playBtn.onclick = startGame;

function animate(t){
  if (!game.running) return;
  if (!last) last = t;
  const dt = Math.min(0.033, (t-last)/1000); last=t;

  // input (one-shot lane changes)
  if (keys.has('ArrowLeft')) { laneLeft(); keys.delete('ArrowLeft'); }
  if (keys.has('ArrowRight')){ laneRight(); keys.delete('ArrowRight'); }
  if (keys.has('ArrowUp'))   { jump(); keys.delete('ArrowUp'); }
  if (keys.has('ArrowDown')) { slide(); keys.delete('ArrowDown'); }

  // timers
  if (game.jumpT>0)  game.jumpT  -= dt;
  if (game.slideT>0) game.slideT -= dt;
  if (game.magnet>0) game.magnet -= dt;
  if (game.invul>0)  game.invul  -= dt;
  game.laneLerp += dt;

  // speed ramp
  game.speed = Math.min(game.max, game.speed + game.accel);
  game.dist  += game.speed * dt;
  game.score = Math.floor(game.dist*6) + game.coins*25;

  // move track forward & recycle
  const dz = game.speed * dt;
  trackGroup.children.forEach(tile=>{
    tile.position.z += dz;
    if (tile.position.z > camera.position.z + TRACK_LEN*0.5){
      tile.position.z -= TRACK_COUNT * TRACK_LEN;
    }
  });
  s1.position.z = -TRACK_LEN/2 + (trackGroup.children[0].position.z % TRACK_LEN);
  s2.position.z = s1.position.z;

  // forklift pose
  forklift.position.x = laneX();
  forklift.position.y = 0 + jumpOffset();
  forklift.rotation.z = (forklift.position.x - LANES[game.lane]) * 0.05; // little lean

  // spawn cadence
  game.spawnTimers.obst += dt;
  game.spawnTimers.coin += dt;
  game.spawnTimers.power += dt;
  if (game.spawnTimers.obst > Math.max(0.6, 1.4 - game.speed/30)) { spawnObstacle(camera.position.z - TRACK_COUNT*TRACK_LEN); game.spawnTimers.obst=0; }
  if (game.spawnTimers.coin > 1.0) { spawnCoinLine(camera.position.z - TRACK_COUNT*TRACK_LEN - 6); game.spawnTimers.coin=0; }
  if (game.spawnTimers.power > 8.0 && game.magnet<=0) { spawnPower(camera.position.z - TRACK_COUNT*TRACK_LEN - 4); game.spawnTimers.power=0; }

  // advance active objects
  const allLists = [active.obst, active.coin, active.power];
  for (const list of allLists){
    for (let i=list.length-1;i>=0;i--){
      const m = list[i];
      m.position.z += dz * (m.userData.kind==='train' ? 2.0 : 1.0);

      // simple spin for coins/power
      if (m.geometry.type === 'CylinderGeometry') m.rotation.y += 3*dt;
      if (m.geometry.type === 'TorusGeometry') m.rotation.y += 2*dt;

      // cleanup behind camera
      if (m.position.z > camera.position.z + 8){
        poolReturn(m);
        list.splice(i,1);
      }
    }
  }

  // collisions
  const pb = playerBox();

  // coins
  for (const c of active.coin){
    if (c.userData.taken) continue;
    const magnetR = game.magnet>0 ? 1.8 : 0.7;
    if (Math.abs(pb.x - c.position.x) < magnetR && Math.abs((pb.z) - c.position.z) < magnetR && Math.abs(pb.y - c.position.y) < 1.2){
      c.userData.taken=true; game.coins++;
      // pull to forklift if magnet
      c.position.x += (pb.x - c.position.x) * 0.7;
      c.position.y += (pb.y + 0.8 - c.position.y) * 0.7;
      c.position.z = pb.z - 0.5;
    }
  }

  // powerups
  for (const p of active.power){
    if (p.userData.taken) continue;
    if (Math.abs(pb.x - p.position.x) < 0.9 && Math.abs(pb.z - p.position.z) < 1.0){
      p.userData.taken=true; game.magnet = 8; note('Magnet!', 800);
    }
  }

  // obstacles (barrier vs gate)
  for (const o of active.obst){
    const dx = Math.abs(pb.x - o.position.x);
    const dz2 = Math.abs(pb.z - o.position.z);
    if (dx < 0.7 && dz2 < 0.9){
      if (o.userData.kind==='barrier'){
        // must be high enough jump
        if (pb.y < 0.9) { crash(); break; }
      } else {
        // gate overhead: must be sliding (reduced height)
        const sliding = game.slideT>0;
        if (!sliding) { crash(); break; }
      }
    }
  }

  // HUD
  hud.score.textContent = game.score;
  hud.coins.textContent = game.coins;
  hud.best.textContent  = game.best;
  hud.speed.textContent = Math.round(game.speed);
  hud.mag.textContent   = game.magnet>0 ? (game.magnet|0)+'s' : '—';

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}

function poolReturn(m){
  scene.remove(m);
  if (m.geometry.type === 'CylinderGeometry') pool.coin.push(m);
  else if (m.geometry.type === 'TorusGeometry') pool.power.push(m);
  else pool.obst.push(m);
}
function clearActive(){
  for (const list of [active.obst, active.coin, active.power]){
    list.forEach(m=>scene.remove(m));
    list.length = 0;
  }
}

// ---------- Crash / UI ----------
function crash(){
  if (game.invul>0) return;
  game.invul = 0.5;
  game.running = false; game.over=true;
  try { if (game.score > game.best) { game.best = game.score; localStorage.setItem('fork3d_best', String(game.best)); } } catch {}
  // small knockback
  const tStart = performance.now(), startZ = forklift.position.z;
  (function knock(ts){
    const t = (ts - tStart)/300;
    forklift.position.z = startZ + Math.sin(Math.min(1,t)*Math.PI)*0.6;
    renderer.render(scene, camera);
    if (t<1) requestAnimationFrame(knock); else showOverlay();
  })(performance.now());
}
function showOverlay(){
  const box = overlay.querySelector('.panel p');
  box.textContent = `Score: ${game.score} • Coins: ${game.coins} • Best: ${game.best}`;
  overlay.classList.remove('hidden');
}
function note(msg,ms){
  toast.textContent = msg; toast.classList.add('show');
  clearTimeout(note._t); note._t = setTimeout(()=>toast.classList.remove('show'), ms||800);
}

// ---------- Resize ----------
addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// Auto-show overlay on load
// (User presses Play to start)
</script>
</body>
</html>